COMMENT ⊗   VALID 00006 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	% This file contains the MLISP2 part of the LCF system.%
C00006 00003	LET ASSUMPTION(S,X,*)={{ALT ASSUME|SASSUME} <WFF>[SC]}MEAN
C00021 00004	LET TRY(*,N,S,*)LINE={TRY{OPT[NUMBER]}{OPT<TACTIC>}[SC]} 
C00024 00005	
C00029 00006	
C00030 ENDMK
C⊗;
% This file contains the MLISP2 part of the LCF system.%
LET PROOF1(X) EXPRESSION ={ {REP 0 M 
    {[IF NEXT('?$)THEN FAILURE()]{ALT<LINE>|<BADLINE>}';[FLUSH]}} '$}
	MEAN BEGIN PRINT 'ENDPROOF END;

EXPR SC(); IF ¬NEXT('?;)THEN FAILURE();

LET LINE(X)={{ALT <ASSUMPTION>|<DEDUCTION>}} MEAN PRINC TERPRI '?*?*?*?*;

LET COMMENT(*,X)LINE={COMMENT{REP 0 M * {[IF NEXT('?;)THEN FAILURE()][TOKEN]}}}
	MEAN NIL;

LET BADLINE(X)={{REP 0 M * {[IF NEXT('?;)THEN FAILURE()][TOKEN]}}} MEAN
	BEGIN PRINC TERPRI 'SYNTAX? ERROR?;? TRY? AGAIN;
		PRINC TERPRI'?*?*?*?* END;

LET IDENT(X)= {{ALT [IDENTIFIER] | '![INF] | '∂ |'¬ }} MEAN 
	IF X[1] EQ 2 THEN X[3] ELSE IF X[1]≥3 THEN X[2] ELSE X←X[2] ALSO
        IF GET(X,'ITD) ∨
	GET(X,'INFIX) THEN FAILURE() ELSE IF X EQ 'NIL THEN 'NIL?! ELSE X;
EXPR INF(); IF PROPERTY('INFIX) THEN CAR TOKEN() ELSE FAILURE();

LET MKINF(*,XL)LINE={INFIX<IDENTIFIERLIST>}MEAN
	FOR NEW X IN XL DO
 BEGIN PUTPROP(X,T,'INFIX);PUTPROP(X,T,'WDINFIX) END;
LET MKPREF(*,XL)LINE={PREFIX<IDENTIFIERLIST>}MEAN
	FOR NEW X IN XL DO
BEGIN PUTPROP(X,NIL,'INFIX);PUTPROP(X,NIL,'WDINFIX) END;

LET IDENTIFIERLIST(I,IL)={[IDENTIFIER]{REP 0 M * {',[IDENTIFIER]}}}MEAN
	I CONS FOR NEW X IN IL COLLECT CDR X;
LET INFIXTERM(X,Y)={<SIMPLETERM>{REP 0 M * {[INF]<SIMPLETERM>}}}MEAN
	IF NULL Y THEN X ELSE 
	FOR NEW M IN Y DO X←'?! CONS('?! CONS M[1]CONS X)CONS M[2];

LET MUTERM(*,*,XI,*,TAU,*) = {{OPT '[}'α <IDENT> '.<TERM> {OPT ']}} MEAN
 	('?α CONS XI CONS TAU);
LET LAMBDATERM(*,*,IDSEQ,*,TAU,*)={{OPT '[} 'λ{REP 1 M * {<IDENT>}}'.
					<TERM>{OPT ']}}MEAN 
	BEGIN NEW X;X←TAU;FOR NEW I IN REVERSE IDSEQ DO
		X←'?λ CONS I[1] CONS X; RETURN X END;

LET PARAMTERM(X)={{ALT<SOLIDTERM>|'(<TERM> {REP 0 M * {',<TERM>}}')}}
   MEAN	IF X[1] EQ 1 THEN CDR X 
	ELSE X[3]CONS(FOR NEW Y IN X[4]COLLECT CDR Y);

LET SOLIDTERM(X)={{ALT<IDENT>|[NUMBER]|<LAMBDATERM>|<MUTERM>|<TERMNAME>}}
	MEAN X[2];

LET CLOSEDTERM(X)={{ ALT <SOLIDTERM>| '(<TERM>') }}MEAN
	IF X[1] EQ 2 THEN X[3]  ELSE X[2];



LET SIMPLETERM(X,Y)= {<CLOSEDTERM>{REP 0 M * {<PARAMTERM>}}} MEAN
	BEGIN NEW Z;Z←X; RETURN(IF NULL Y THEN Z ELSE FOR NEW L IN Y DO
		FOR NEW M IN L[1] DO Z←'?! CONS Z CONS M)END;
EXPR ITD();PROPERTY('ITD);
LET TERM(X,Y)={<INFIXTERM>{ALT [IF ¬ITD()THEN FAILURE()]
		| '→<TERM>',<TERM>}}MEAN
	IF Y[1] EQ 1 THEN X ELSE
	('?? CONS X CONS Y[3] CONS Y[5]);


LET IDENTLIST(I,IL)={<IDENT>{REP 0 M * {',<IDENT>}}}MEAN
	I CONS FOR NEW X IN IL COLLECT CDR X;

     
LET ASSUMPTION(S,X,*)={{ALT ASSUME|SASSUME} <WFF>[SC]}MEAN
	FOR NEW A IN X DO BEGIN IF S[1] EQ 2 THEN 
 	    SIMPSET←PUT1IN(A,THISLINE,<THISLINE>,SIMPSET,NIL);
	NEWSTEP(<<<A>,THISLINE>,CDR S>)END;


EXPR STEPREF(V); FOR NEW P IN PROOF DO
	IF EQ(V,CADR P) THEN RETURN CAR P;

LET AWFF(PL,X,R,Y)={{REP 0 M * {{ALT '∀ {REP 1 M * {<IDENT>}}'.|
				<TERM> ': ':}} }
	<TERM><REL><TERM>}MEAN 
	BEGIN FOR NEW P IN REVERSE PL DO
	IF P[1,1] EQ 1 THEN FOR NEW V IN REVERSE P[1,3] DO
		BEGIN  X ← '?λ CONS V[1] CONS X;
		Y ← '?λ CONS V[1] CONS Y END
	ELSE X ← '?? CONS P[1,2] CONS X CONS 'UU
	ALSO Y ← '?? CONS P[1,2] CONS Y CONS 'UU ;
	RETURN( R CONS X CONS Y )
	END;

LET WFF(A,W)={<AWFF>{REP 0 M * {',<AWFF>}}}MEAN
	A CONS FOR NEW I IN W COLLECT CDR I;
LET REL(R)={{ALT '≡|'⊂}}MEAN R[2];

LET DEDUCTION(X)={{ALT <INCL>|<CONJ>}}MEAN NEWSTEP(X[2]);

LET CANCEL(*,X,*)LINE={CANCEL{OPT<LINENO>}[SC]} MEAN
	BEGIN NEW B,N,M; M←IF X THEN CAR X ELSE THISLINE-1;
	WHILE THISLINE GREATERP M ∧ 
	(((B←ATOM(N←CAAR PROOF)) ∧ N≥M )∨(¬ATOM(CADAR PROOF)∧¬ATOM N ))
	DO IF B THEN SIMPSET←TAKE1OUT(N,SIMPSET)ALSO THISLINE←N 
	ALSO PROOF←CDR PROOF ELSE BACKUP(NIL);
	PRINC TERPRI'CANCELLED? BACK? THRU? ;TERPRI PRINC THISLINE
	END;

LET LABEL(*,X,Y,*)LINE={{ALT LABEL|LABELS} <LABITEM>
		{REP 0 M * { ', <LABITEM>}} [SC]}
	MEAN T;

LET LABITEM(X) = {{ALT <LABITEM3>|<LABITEM2>|<LABITEM1>}} MEAN T;

LET LABITEM1(X) = { <IDENT> } MEAN
	LABELALIST←(X CONS THISLINE) CONS LABELALIST;
LET LABITEM2(*,X,*,Y,*) = { '( <IDENT> {ALT ', | '= } <LINENO> ') }
	MEAN LABELALIST←(X CONS Y) CONS LABELALIST;
LET LABITEM3(X,Y) = {<IDENT> <LINENO>}
	MEAN LABELALIST←(X CONS Y) CONS LABELALIST;


LET VL(X)={<LINENO>}MEAN LINEOF(X);

LET VLLIST(V,VLL)={<VL>{REP 0 M * {',<VL>}}}MEAN
	V CONS FOR NEW X IN VLL COLLECT CDR X;

LET LINENO(X)={{ALT [NUMBER]|{REP 1 M * {'-}}|<LABELREF>}}
MEAN IF (X[1] EQ 1) ∨ (X[1] EQ 3) THEN X[2] 
     ELSE THISLINE-LENGTH(X[2]);

LET LABELREF(*,X,Y) = {'. <IDENT> {OPT {ALT '+|'-} [NUMBER]}}
MEAN BEGIN NEW Z;
	Z←ASSOC(X,LABELALIST);
	IF NULL(Z) THEN ERR("UNDEFINED LABEL");
	Z←CDR(Z);
	IF NULL(Y) THEN RETURN Z;
	IF CAAR(Y) EQ 1 THEN Z←Z+Y[2] ELSE Z←Z-Y[2];
	RETURN(Z);
     END;


LET INCL(*,X,*,N,*)={INCL <VL>',[NUMBER][SC]}MEAN
	<IF N≤LENGTH(CAR X)THEN <(CAR X)[N]>CONS CDR X ELSE'NASTYINCL,
	 <'INCL,STEPREF(X)>  >;

LET CONJ(*,L,*)={CONJ<VLLIST>[SC]} MEAN
	< (FOR NEW V IN L COLLECT CAR V)CONS
	  (FOR NEW V IN L ; UNION CDR V),

	'CONJ CONS FOR NEW V IN L COLLECT <STEPREF(V)> >;

LET CUT(*,X,*,Y,*)DEDUCTION={CUT<VL>',<VL>[SC]}MEAN
	<IF CONTP(FOR NEW I IN CDR Y COLLECT CAR LINEOF(I),
					CAR X, FUNCTION EQUALTERM)
	THEN CAR Y CONS CDR X 
		ELSE 'NASTYCUT , < 'CUT,STEPREF(X),STEPREF(Y)>>;

LET HALF(*,X,*)DEDUCTION={HALF<VL>[SC]} MEAN 
	<<'?⊂ CONS CDAAR X> CONS CDR X ,<'HALF,STEPREF(X)>>;

LET SYM(*,X,*)DEDUCTION={SYM<VL>[SC]}MEAN
	 <IF CAAAR X EQ '?≡ THEN <'?≡ CONS CDDAAR X CONS
	    CADAAR X>CONS CDR X  ELSE 'NASTYSYM ,<'SYM,STEPREF(X)>>;

LET TRANSI(*,Y,*,Z,*)DEDUCTION={TRANS<VL>',<VL>[SC]}MEAN 
	<IF EQUALTERM(CDDAAR Y,CADAAR Z) THEN
	<(IF (CAAAR Y EQ '?≡)∧(CAAAR Z EQ '?≡) THEN '?≡ ELSE '?⊂)
	   CONS CADAAR Y CONS  CDDAAR Z> CONS UNION(CDR Y,CDR Z)
	ELSE 'NASTYTRANS ,<'TRANS,STEPREF(Y),STEPREF(Z)>>;


LET TERMNAME(X)={{  ALT {OPT ':<VL>{OPT ':[NUMBER]}}':{ALT 'L|'R} |
	': 'G {OPT ':[NUMBER]}':{ALT 'L|'R} }}
	MEAN
	BEGIN NEW Y,W,OPTN,LR;   IF X[1] EQ 2 THEN
	W← ( IF THISGOAL THEN CDR THISGOAL ELSE
		TERPRI PRINC 'THISGOAL? NONEXISTENT 
		ALSO <<'?≡ CONS 'BOOB CONS 'BOOB>> )  
			ALSO OPTN←X[4] ALSO LR←X[6]      ELSE
	W← ( IF X[2] THEN X[2,2] ELSE LINEOF(THISLINE-1) )
	ALSO OPTN← (IF X[2] THEN X[2,3]) ALSO LR←X[4]
	;  Y← W[1,IF OPTN THEN OPTN[2] ELSE 1];
	RETURN(IF CAR LR EQ 1 THEN CADR Y ELSE CDDR Y)  END;

LET APPL(*,P,*)DEDUCTION = {APPL {ALT<VL>',<TERM>{REP 0 M * {',<TERM>}} |
	 <TERM>',<VL>}[SC]}MEAN
	BEGIN NEW L,M;RETURN IF P[1] EQ 1 THEN L←CAAR(P[2])ALSO
	 M←P[4]CONS FOR NEW X IN P[5] COLLECT CDR X ALSO
		< < FOR NEW X IN M DO L ←
	CAR L CONS('?! CONS CADR L CONS X)CONS('?! CONS CDDR L CONS X)>
	CONS CDR(P[2]),
		'APPL CONS STEPREF(P[2]) CONS M >
	ELSE  M←P[2] ALSO L←CAAR(P[4]) ALSO
	<<CAR L CONS('?! CONS M CONS CADR L)CONS('?! CONS M CONS CDDR L)>
	CONS CDR(P[4]),
		<'APPL,M,STEPREF(P[4])>>
	END;

LET ABSTR(*,W,*,XL,*)DEDUCTION={ABSTR<VL>',<IDENTLIST>[SC]} MEAN
	<IF INTERSECTP(XL,
		(FOR NEW I IN CDR W COLLECT FREES(CAR(LINEOF(I)))) UNION
		  (FOR NEW I IN AXIOMLIST COLLECT FREES(CDR I)) UNION
			<'TT,'UU,'FF>,	FUNCTION EQ)THEN
		'NASTYABSTR ELSE
	BEGIN NEW PRE;PRE←FOR NEW X IN XL COLLECT<'?λ,X>;
	RETURN(<CAAAR W CONS(PRE @ CADAAR W)
		CONS(PRE @ CDDAAR W)> CONS CDR W)
	END  , <'ABSTR,STEPREF(W)>>;

LET CONV(*,R,*)DEDUCTION={CONV{ALT<VL>|<TERM>}[SC]}MEAN
	BEGIN NEW S; 
	    S←SIMPLIFY1(R,LAMSS);
	RETURN<CDR S, <'CONV,IF R[1] EQ 2 THEN R[2] ELSE STEPREF(R[2])>>
	END;

LET ETACONV(*,S,*)DEDUCTION = {ETACONV <TERM> [SC] } MEAN
	< IF ¬ATOM(S)∧(CAR S EQ  '?λ)∧ ¬ATOM(CDDR(S))∧(CADDR S EQ '?!)∧
	     CDDDDR S EQ CADR S ∧ ¬MEMQ(CADR S, FREES(CADDDR S))  THEN
	 <<'?≡ CONS S CONS CADDDR S>>  ELSE 'NASTYETACONV, <'ETACONV,S> >;


EXPR BADCONV(R); ATOM R ∨ CAR R≠'?! ∨ ATOM CADR R ∨ CAADR R≠'?λ ;

EXPR CONVTERM(R);BEGIN NEW S,TM;RETURN SUBSTFREE(TM←CDDR R,CADADR R,
		MUTATE(S←CDDADR R,FREES(S) UNION FREES(TM)))
	END;


LET EQUIV(*,X,*,Y,*)DEDUCTION={EQUIV<VL>',<VL>[SC]} MEAN
	<IF EQUALTERM(CADAAR X,CDDAAR Y)∧ EQUALTERM(CDDAAR X,CADAAR Y)
	THEN<'?≡ CONS CDAAR X>CONS(CDR X UNION CDR Y)
	ELSE'NASTYEQUIV , <'EQUIV,STEPREF(X),STEPREF(Y)>>;

EXPR REFL(C,S);<<C CONS S CONS S>>;

LET REFL1(*,S,*)DEDUCTION={REFL1<TERM>[SC]} MEAN
	<REFL('?≡,S) , <'REFL1,S>>;

LET REFL2(*,S,*)DEDUCTION={REFL2<TERM>[SC]}MEAN
	<REFL('?⊂,S) , <'REFL2,S>>;

LET MIN1(*,S,*)DEDUCTION={MIN1<TERM>[SC]} MEAN
	<<< '?⊂ CONS 'UU CONS S>> , <'MIN1,S>>;
LET MIN2(*,S,*)DEDUCTION={MIN2<TERM>[SC]} MEAN
	<<< '?≡ CONS('?! CONS 'UU CONS S)CONS 'UU>> , <'MIN2,S>>;
LET CONDT(*,R,*)DEDUCTION={CONDT<TERM>[SC]} MEAN
	<<<'?≡ CONS R CONS REDT(R,'TT,CADDR R)>>, <'CONDT,R>>;
LET CONDU(*,R,*)DEDUCTION={CONDU<TERM>[SC]} MEAN
	<<<'?≡ CONS R CONS REDT(R,'UU,'UU)>>, <'CONDU,R>>;
LET CONDF(*,R,*)DEDUCTION={CONDF<TERM>[SC]} MEAN
	<<<'?≡ CONS R CONS REDT(R,'FF,CDDDR R)>>, <'CONDF,R>>;
EXPR REDT(R,TV,S);IF CAR R EQ '?? ∧ CADR R EQ TV THEN S ELSE 'NASTYCOND;

LET FIXP(*,W,*)DEDUCTION={FIXP<VL>[SC]} MEAN

	< BEGIN NEW ETA,S,FIXT;RETURN
	IF CAAAR W EQ '?≡ ∧ CAR(FIXT←CDDAAR W) EQ '?α
	THEN<'?≡ CONS (ETA←CADAAR W)CONS SUBSTFREE(ETA,CADR FIXT,
		MUTATE(S←CDDR FIXT,FREES(S) UNION FREES(ETA)))>CONS CDR W
	ELSE 'NASTYFIXP  END , <'FIXP,STEPREF(W)>>;

LET CHANGESIMP(*,OP,IL,*)LINE={{ALT SS|SIMPSET}{ALT '+|'-}
			<SIMPITEMLIST>[SC]} MEAN
	SIMPSET ← CHGSS( <OP[1] CONS IL>,SIMPSET);



LET SUBS(*,L,N,*,Z,*)DEDUCTION={SUBST<VL>{OPT OCC<NUMLIST>}IN
{ALT<VL>|<TERM>}[SC]}
	MEAN<SUBS1(L,N,Z),<'SUBST,STEPREF(L),N,'IN,IF Z[1] EQ 2 
	THEN Z[2] ELSE STEPREF(Z[2]) >>;

LET SIMPLIFY(*,Z,SL,*)DEDUCTION={SIMPL{ALT<VL>|<TERM>}<SIMPLIST>[SC]}MEAN
	BEGIN NEW S;
	S←SIMPLIFY1(Z,CHGSS(SL,SIMPSET));
	RETURN < CDR S,
	<'SIMPL,IF Z[1] EQ 2 THEN Z[2] ELSE STEPREF(Z[2])> @
	IF CAR S THEN 'BY CONS CAR S >  END;

LET SIMPLIST(L) = {{REP 0 M * { {OPT ',} {ALT <SIMPSEG1>|<SIMPSEG2>}}}}
	MEAN FOR NEW I IN L COLLECT <I[2,2]>;

LET SIMPSEG1(*,S) = { BY <SIMPITEMLIST>} MEAN 1 CONS S;

LET SIMPSEG2(*,S) = { WO <SIMPITEMLIST>} MEAN 2 CONS S;

LET SIMPITEMLIST(S1,S2) = {<SIMPITEM> {REP 0 M * {', <SIMPITEM>}}}
	MEAN S1 APPEND (FOR NEW I IN S2 COLLECT CADR I);

LET SIMPITEM(SI,SS,LS)= {<SIMPELT> {OPT '/'S} {OPT '/'L}}
	MEAN BEGIN NEW X;
		   X ← (IF SS THEN 1 ELSE 0)+(IF LS THEN 2 ELSE 0);
		   RETURN(FOR NEW Y IN SI
				 COLLECT <(CAR Y + X) CONS (CDR Y)>)
	     END;

LET SIMPELT(SE) = {{ALT <RANGE> | <IDENT> | <LINENO>}}  
	MEAN IF (CAR SE EQ 3) THEN < 0 CONS CADR(SE)> ELSE
		IF (CAR SE EQ 2) THEN <4 CONS CADR(SE)>  ELSE
		    FOR NEW I ←SE[2,1] TO SE[2,2] 
			COLLECT < 0 CONS I>;

EXPR CHGSS(CL,SS);
BEGIN
	FOR NEW A IN CL DO 
	    IF CAR(A) EQ 1 THEN SS←CHGSS1(CDR A,SS)
	    ELSE SS←CHGSS2(CDR A,SS);
	RETURN SS;
END;

EXPR CHGSS1(AL,SS);
BEGIN
	FOR NEW A IN AL DO
	IF LESSP(CAR A, 4) THEN
	    BEGIN NEW X;
		X←LINEOF(CDR A);
		FOR NEW Y IN CAR(X) DO
		SS←PUT1IN( IF (CAR A EQ 1)∨(CAR A EQ 3) THEN
				CAR(Y) CONS (CDDR(Y) CONS CADR(Y))
				ELSE Y,
			    CDR(A),CDR X,SS,NIL);
	    END
	ELSE BEGIN NEW X;
		X←LKUPTHM(CDR A);
		IF ATOM(X) THEN ERR(X);
		FOR NEW Y IN X[3] DO
		SS←PUT1IN( IF (CAR A EQ 5)∨(CAR A EQ 7) THEN
				CAR(Y) CONS (CDDR(Y) CONS CADR(Y))
				ELSE Y,
			    CDR(A),X[2],SS,X[4]);
	    END;
	RETURN SS;
END;

EXPR CHGSS2(SL,SS);
BEGIN
	FOR NEW S IN SL DO
	SS←TAKE1OUT(CDR S, SS);
	RETURN SS;
END;


LET NUMLIST(N,L)={<LINENO>{REP 0 M * {',<LINENO>}}}MEAN
	(N CONS FOR NEW M IN L COLLECT CDR M);


LET SS_SAV(*,*,V)LINE={SAVE SIMPSET <IDENT>} MEAN
	PUTPROP(V,SIMPSET,'SIMPSET);

LET SS_RSTR(*,*,V)LINE={RESTORE SIMPSET <IDENT>} MEAN
	SIMPSET ← GET(V,'SIMPSET);
LET TRY(*,N,S,*)LINE={TRY{OPT[NUMBER]}{OPT<TACTIC>}[SC]} 
    MEAN TRYMN(N,S);

LET TACTIC(X,*)={{ALT  CASES <TERM> | ABSTR | SIMPL <SIMPLIST> |
	SUBST<VL>{OPT OCC<NUMLIST>} | INDUCT<VL>{OPT OCC<NUMLIST>} |
	USE <IDENT>{OPT ',}{OPT<INSTLIST>} | CONJ | PREF | SPREF<SIMPLIST> |
	SSUBST<VL>{OPT OCC<NUMLIST>}<SIMPLIST> | SCASES<TERM><SIMPLIST>  }
	[SC]}MEAN X;

LET QED(*,N,*)LINE={QED{OPT <LINENO>}[SC]} MEAN  
BEGIN NEW S,T1,T2,TV;  RETURN IF
	MEMQ(T1←CADAR(S←CAR(LINEOF(IF N THEN CAR N ELSE THISLINE-1))),
	TV←'(TT,UU,FF) ) ∧
	MEMQ(T2←CDDAR S,TV) ∧ T1≠T2 ∧(CAAR S EQ '?≡ ∨ T1≠'UU) ∨
	 CONTP(CADR THISGOAL,S,FUNCTION EQUALTERM)
	THEN (IF N THEN NEWSTEP(<LINEOF(CAR N),<'INCL,N>>)) ALSO 
	METHOD←<'QED> ALSO BACKUP(T)  ELSE  PRINC TERPRI
				'NOT? PROVED END;

LET ABANDON(*,*)LINE={ABANDON [SC]} MEAN IF GOALNO THEN BACKUP(NIL)
	ELSE PRINC TERPRI 'NO? GOAL? UNDER? TRIAL ;

LET GOAL(*,W1,W2,*)LINE={GOAL <WFF> {OPT{ALT ASSUME|SASSUME}<WFF>}[SC]} MEAN
	BEGIN PRINT'NEWGOAL;PRINTGN((NSG←NSG+1)CONS GOALNO);
	PRINTWFF(W1); IF W2 THEN
	BEGIN PRINC'? ;PRINC(W2[1,2]);PRINC'? ;PRINTWFF(W2[2])
	END;
	GOALLIST←GOALLIST@<NIL CONS W1 CONS(IF W2 THEN W2[1]CONS W2[2])>;
	FREESPR ← FREESPR UNION FREES(W1);
	END;

EXPR PRINTGN(GN);FOR NEW N IN REVERSE GN DO BEGIN PRINC'?#;PRINC N END;
     
LET SCRATCH(*,G,*)LINE = {SCRATCH [NUMBER][SC]} MEAN
	IF ¬(1≤G∧G≤NSG) THEN PRINC 'NO? SUCH? GOAL ELSE
	IF G≤NTACSG THEN PRINC 'NO?!?!? ITS? TACTICAL?!  ELSE
	IF SCRX(G) THEN PRINC('NO?!?!? LATER? GOALS? ARE? )
			ALSO PRINC('ALREADY? PROVED?.)  ELSE
	PRINC'OK?.? LATER? GOALS? RENUMBERED  ALSO NSG←NSG-1 ALSO
	GOALLIST←OUTOFP(GOALLIST[G],GOALLIST,FUNCTION EQ);

EXPR SCRX(G);
BEGIN NEW X,FLG;
    FOR X←G+1 TO NSG DO IF CAR(GOALLIST[X]) THEN FLG←T;
    RETURN(FLG);
END;

LET AXIOM(AX,AXNAME,*,W1,W,*)LINE = {AXIOM <IDENT>{OPT ':}{ALT<AWFF>|<VL>}
		{REP 0 M * {',{ALT<AWFF>|<VL>}[FLUSH]}}[SC]}MEAN
	BEGIN NEW AXWFF; PRINT AX;TERPRI PRINC AXNAME; 
	AXWFF←(IF CAR W1 EQ 2 THEN CAR W1[2] ELSE CDR W1) @
	FOR NEW X IN W COLLECT IF X[2,1] EQ 2 THEN CAR X[2,2] ELSE CDR X[2];
	FOR NEW A IN AXWFF DO NEWSTEP(<<<A>>,<AXNAME,AX>>);
	AXIOMLIST←(AXNAME CONS AXWFF)CONS AXIOMLIST
	END;
LET THEOREM(TH,AXLIST,THNAME,*,W,*)LINE = {THEOREM {OPT '( <IDENTLIST>')}
					<IDENT>{OPT ':}{ALT <VL>
					|<WFF>{OPT ASSUME<WFF>}}[SC]}
MEAN THEORMNG(TH,AXLIST,THNAME,W);


LET USE(*,THNAME,*,VLL,*,INSTL,*)DEDUCTION = {USE <IDENT> 
		{OPT ',}{OPT<VLLIST>}{OPT ',}{OPT<INSTLIST>}[SC]}  
    MEAN USEMNG(THNAME,VLL,INSTL);

LET INSTLIST(I,IL) = {<INST>{REP 0 M * {',<INST>}}}MEAN
	I CONS FOR NEW X IN IL COLLECT CDR X;
LET INST(I,*,TM)={<IDENT>'←<TERM>} MEAN I CONS TM;
LET SHOW(*,TYPE,RL,L,DEST,*)LINE={SHOW {ALT GOALTREE|THISGOAL|
     GOALLIST|PROOF|{ALT STEP|STEPS}|{ALT THEOREM|THEOREMS|FORMAT2}|
	{ALT AXIOM|AXIOMS}|SIMPSET|{ALT LABEL|LABELS}}
	    {OPT<RANGELIST>}{OPT '(<IDENTLIST>')}
		{OPT{ALT<IDENT>|LPT ':}{OPT[NUMBER]}}[SC]}  
    MEAN SHOWMNG(TYPE,RL,L,DEST);

LET ISAVE(*,FN,*)LINE = {ISAVE <FILNAM> [SC]} MEAN
BEGIN
    IF SAVING THEN CLOSESAVCHAN;
    IF FN THEN EVAL(<FUNCTION OUTPUT, 'SAVCHAN, 'DSK?:, CAR FN>)
	ALSO SAVING ←T;
END;

LET FETCH(*,FL,*)LINE={FETCH<FILNAMLIST>[SC]}MEAN
    BEGIN NEW X,Y;
	IF IO_LEVEL EQ 0 THEN X←'CH0 ELSE
	IF IO_LEVEL EQ 1 THEN X←'CH1 ELSE
	IF IO_LEVEL EQ 2 THEN X←'CH2 ELSE
	IF IO_LEVEL EQ 3 THEN X←'CH3 ELSE
	ERR('TOO? MANY? LEVELS? OF? FETCH?.);
	IO_LEVEL ← IO_LEVEL + 1;
	INC(EVAL(<FUNCTION INPUT,X,'DSK?:>@FL),NIL);
    END;

LET FILNAMLIST(X)={ {REP 1 M *{ <FILNAM> } ',} }
	MEAN
	 FOR NEW I IN X COLLECT CAR I;

LET FILNAM(X,Y,Z)={ [IDENTIFIER]{OPT '. [IDENTIFIER]}
			{OPT '[ <IDENTORINT> ', [IDENTIFIER] '] } }
	MEAN
	 BEGIN NEW P;
	 IF Y THEN P←<X CONS Y[2]> ELSE P←<X>;
	 IF Z THEN P←<Z[2],Z[4]> CONS P;
	 RETURN P;
	 END;

LET IDENTORINT(X)
	={ {ALT [IDENTIFIER]|[INTEGER]} } MEAN X[2];

EXPR INTEGER();
	IF NUMBERP(?!SCANVAL)∧INTEG(?!SCANVAL)
	 THEN CAR TOKEN()
	 ELSE FAILURE();

INLINE	(LAP	INTEG   SUBR)
	(CALL   1   (E NUMVAL))
	(CAIE   2   (QUOTE FIXNUM))
	(TDZA   1   1 )
	(MOVEI  1   (QUOTE T))
	(POPJ   P  )
	NIL;

LET RANGE(X)= {{ALT {OPT<LINENO>}': {OPT <LINENO>} | <LINENO> }}MEAN
	IF X[1] EQ 1 THEN <IF X[2] THEN X[2,1]ELSE 0, 
		IF X[4]THEN X[4,1]ELSE THISLINE>  ELSE <X[2],X[2]>;

LET RANGELIST(R,L)={<RANGE>{REP 0 M * {',<RANGE>}}} MEAN
	R CONS FOR NEW X IN L COLLECT CDR X;

LET ESCAPE(*,*)LINE = {ESCAPE [SC]} MEAN ESCAPEMNG();

EXPR ESCAPEMNG(); EVAL(READ());

FOR NEW X IN '(?∩ ?∪ ?$ ?_ ?| ?+ ?- ?⊗ ?* ?∧ ?∨ ?& ?/ ?\ ?@ ?←
	?≤ ?≥ ?< ?> ?≠ ?= ?↔ ?↑ ?↓ ?ε ) DO PUTPROP(X,T,'INFIX);
FOR NEW X IN '(?] ?) ?; ?: ?, ?. ?≡ ?⊂ ASSUME SASSUME BY WO)
	DO PUTPROP(X,T,'ITD);

LET PROGRAM(X) = {<PROOF1>} MEAN NIL;

_EOF_
